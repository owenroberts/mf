{"version":3,"sources":["doodoo.min.js","Doodoo.js"],"names":["window","Doodoo","params","callback","samples","debug","isPlaying","defaultDuration","duration","scale","voices","length","push","recorder","recordingMutationCount","withRecording","Tone","Recorder","prompt","tonic","MIDI_NOTES","transform","def","defaults","controls","effects","Effects","parts","melody","map","n","Part","Array","isArray","i","durations","p","parseInt","Math","max","currentPart","totalPlays","simultaneous","attackStart","ValueRange","attackStep","restChance","toneLoop","loops","currentCountTotal","currentCount","useMetro","metro","async","loadTone","start","filter","v","includes","urls","forEach","voice","split","letter","voiceSampleURLS","SamplePaths","note","loadSamples","console","time","join","ToneAudioBuffers","baseUrl","onload","timeEnd","load","err","error","Loop","loop","Transport","bpm","value","seconds","playTheme","MetalSynth","volume","frequency","envelope","attack","decay","release","harmonicity","modulationIndex","resonance","octaves","toDestination","currentParts","part","getLoops","harmony","getMelody","getHarmony","getVoice","random","beat","beats","countNum","doubler","counter","noteDuration","countEnd","repeat","startDelay","len","l","mutationCount","update","onMutate","state","stop","saveRecording","triggerAttackRelease","getRandom","count","j","chance","floor","startIndex","t","Time","toSeconds","doublerCounter","min","fmSynth","FMSynth","chain","Destination","get","f","connect","getSynth","sampleFiles","getSampleFiles","sampler","Sampler","getSampler","recording","url","URL","createObjectURL","anchor","document","createElement","audioName","Date","toDateString","replace","download","href","click","lazyLoad","play","autoLoad","mutate","moveTonic","dir","indexOf","setTonic","moveBPM","b","setBPM","getIsPlaying","isRecording","printLoops","log"],"mappings":"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","file":"../doodoo.min.js","sourcesContent":[null,"function clamp(value, min, max) {\n\treturn Math.min(Math.max(value, min), max);\n}\n\nfunction Doodoo(params, callback) {\n\t\n\tlet debug = params.debug;\n\tlet isPlaying = false;\n\tlet defaultDuration = params.duration || '4n';\n\tlet scale = params.scale || [0, 2, 4, 5, 7, 9, 11]; // major\n\t\n\tlet samples;\n\tlet voices = params.voices || [params.samples]; // fix for old data\n\tif (voices.length === 0) voices.push('FMSynth');\n\n\tlet withRecording = params.withRecording;\n\tlet recorder, recordingMutationCount;\n\n\tif (withRecording) {\n\t\trecorder = new Tone.Recorder();\n\t\trecordingMutationCount = +prompt('Record number of mutations?', 10);\n\t}\n\t\n\tlet tonic = typeof params.tonic === 'string' ?\n\t\tparams.tonic :\n\t\tMIDI_NOTES[params.tonic];\n\n\tif (!params.transform) params.transform = params.tonic;\n\tlet transform = typeof params.transform === 'string' ?\n\t\tparams.transform :\n\t\tMIDI_NOTES[params.transform];\n\n\tlet def = { ...defaults, ...params.controls }; // defaults\n\t// console.log('defaults', def);\n\tlet effects = new Effects(def);\n\n\t/*\n\t\tparts data struture is currently convoluted\n\t\tall compositions have one part so far -- but idea of multiple parts is cool\n\t\tsome parts are just notes with no durations ['C4', 'C4', 'A4'] etc\n\t\tsome parts are array of arrays [['C4', '4n'], ['A4', '4n']], these go inside another array which is the \"part\"\n\n\t\tfor now use just [] and [[]] figure out [[[]]] later\n\t*/\n\n\tlet parts = [];\n\tif (typeof params.parts[0] === 'string') {\n\t\tconst melody = params.parts.map(n => [n, defaultDuration]);\n\t\tparts.push(new Part(melody, def, defaultDuration, debug));\n\t} else if (typeof params.parts[0] === 'number') {\n\t\tconst melody = params.parts.map(n => [MIDI_NOTES[n], defaultDuration]);\n\t\tparts.push(new Part(melody, def, defaultDuration, debug));\n\t} else if (Array.isArray(params.parts[0])) {\n\t\tif (Array.isArray(params.parts[0][0])) {\n\t\t\tfor (let i = 0; i < params.parts.length; i++) {\n\t\t\t\tconst melody = params.parts[i];\n\t\t\t\tparts.push(new Part(melody, def, defaultDuration, debug));\n\t\t\t\tconst durations = params.parts[i].map(p => parseInt(p[1]));\n\t\t\t\tdefaultDuration = Math.max(...durations) + 'n';\n\t\t\t}\n\t\t} else {\n\t\t\tconst melody = params.parts;\n\t\t\tparts.push(new Part(melody, def, defaultDuration, debug));\n\n\t\t\tconst durations = params.parts.map(p => parseInt(p[1]));\n\t\t\tdefaultDuration = Math.max(...durations) + 'n';\n\t\t}\n\t}\t\n\n\tlet currentPart = 0;\n\tlet totalPlays = 0;\n\tlet simultaneous = params.simultaneous || false;\n\n\t// attack velocity -- only (?) global params\n\tconst attackStart = new ValueRange(...def.attackStart);\n\tconst attackStep = new ValueRange(...def.attackStep);\n\tconst restChance = new ValueRange(...def.restChance);\n\n\tlet toneLoop;\n\tlet loops = [];\n\tlet currentCountTotal = 0;\n\tlet currentCount = 0;\n\n\tconst useMetro = params.useMetro;\n\tlet metro;\n\n\t// start tone using async func to wait for tone\n\tasync function loadTone() {\n\t\ttry {\n\t\t\tawait Tone.start();\n\t\t\tif (voices.filter(v => !v.includes('Synth')).length > 0) load(start);\n\t\t\telse start();\n\t\t} catch(err) {\n\t\t\tconsole.error('load tone error', err);\n\t\t}\n\t}\n\n\tif (!params.lazyLoad) loadTone();\n\n\tfunction start() {\n\t\tif (callback) callback();\n\t\ttoneLoop = new Tone.Loop(loop, defaultDuration);\n\t\tTone.Transport.start();\n\t\tif (params.bpm) Tone.Transport.bpm.value = params.bpm;\n\t\ttoneLoop.start(Tone.Transport.seconds);\n\t\tplayTheme();\n\t\t\n\t\tif (useMetro) {\n\t\t\tmetro = new Tone.MetalSynth({\n\t\t\t\tvolume: -12,\n\t\t\t\tfrequency: 250,\n\t\t\t\tenvelope: {\n\t\t\t\t\tattack: 0.01,\n\t\t\t\t\tdecay: 0.01,\n\t\t\t\t\trelease: 0.2\n\t\t\t\t},\n\t\t\t\tharmonicity: 3.1,\n\t\t\t\tmodulationIndex: 32,\n\t\t\t\tresonance: 4000,\n\t\t\t\toctaves: 1.5,\n\t\t\t}).toDestination(); \n\t\t}\n\n\t\tisPlaying = true;\n\t\tif (withRecording) recorder.start();\n\t}\n\n\tfunction playTheme() {\n\t\tcurrentCount = 0;\n\t\tloops = [];\n\n\t\tlet currentParts = simultaneous ? parts : [parts[currentPart]];\n\t\tcurrentParts.forEach(part => {\n\t\t\tpart.getLoops().forEach(params => {\n\t\t\t\tconst part = {\n\t\t\t\t\t...params,\n\t\t\t\t\tmelody: params.harmony === 0 ? \n\t\t\t\t\t\tgetMelody(params.melody, tonic, transform) :\n\t\t\t\t\t\tgetHarmony(params.melody, tonic, transform, params.harmony, scale),\n\t\t\t\t\tvoice: getVoice(random(voices))\n\t\t\t\t};\n\t\t\t\tloops.push(part);\n\t\t\t});\n\t\t});\n\n\t\t/* play notes on default beat ...*/\n\t\tloops.forEach(loop => {\n\t\t\tlet n = [];\n\t\t\tloop.melody.forEach(beat => {\n\t\t\t\tconst [note, duration] = beat;\n\t\t\t\tlet beats = +defaultDuration[0] / +duration[0];\n\t\t\t\tif (duration.includes('.')) beats *= 1.5;\n\t\t\t\tn.push(beat);\n\t\t\t\tfor (let i = 1; i < beats; i++) {\n\t\t\t\t\tn.push([null, defaultDuration]);\n\t\t\t\t}\n\t\t\t});\n\t\t\tloop.melody = n;\n\t\t\tloop.countNum = loop.doubler ? (loop.counter * loop.noteDuration) / 4 : 1;\n\t\t\tloop.countEnd = (loop.melody.length - 1) * loop.repeat + loop.startDelay;\n\t\t\tloop.len = loop.melody.length;\n\t\t});\n\n\t\tcurrentCountTotal = Math.max(0, Math.max(...loops.map(l => l.melody.length)));\n\n\t\tlet mutationCount = currentParts.map(part => part.update())[0];\n\t\tif (params.onMutate) params.onMutate(mutationCount);\n\n\t\t// console.log(currentPart, loops.map(l => l.noteDuration), loops.map(l => l.melody));\n\t\tif (!simultaneous) {\n\t\t\tcurrentPart++;\n\t\t\tif (currentPart >= parts.length) currentPart = 0;\n\t\t}\n\t\ttotalPlays++;\n\t\t\n\t\tif (Tone.Transport.state === 'stopped') Tone.Transport.start();\n\n\t\tif (mutationCount > recordingMutationCount) {\n\t\t\tTone.Transport.stop();\n\t\t\tisPlaying = false;\n\t\t\tsaveRecording();\n\t\t}\n\t}\n\n\tfunction loop(time) {\n\t\tif (useMetro) metro.triggerAttackRelease('C4', '4n', time, 0.1);\t\n\t\tlet attack = attackStart.getRandom();\n\t\tfor (let i = 0; i < loops.length; i++) {\n\t\t\tconst loop = loops[i];\n\t\t\tif (loop.count > loop.countEnd) continue;\n\t\t\tfor (let j = 0; j < loop.countNum; j++) {\n\t\t\t\tif (loop.count < loop.startDelay) continue;\n\t\t\t\tif (loop.count % 1 !== 0 && !loop.doubler) continue;\n\t\t\t\tif (chance(restChance.getRandom())) continue;\n\t\t\t\tconst beat = loop.melody[Math.floor(loop.count - loop.startDelay + loop.startIndex) % loop.len];\n\t\t\t\tif (beat[0] !== null) {\n\t\t\t\t\tconst [note, duration] = beat;\n\t\t\t\t\t// time offset for doubles\n\t\t\t\t\tlet t = j ? Tone.Time(`${loop.noteDuration}n`).toSeconds() * j : 0; \n\t\t\t\t\tloop.voice.triggerAttackRelease(note, duration, time + t, attack);\n\t\t\t\t}\n\t\t\t\tif (loop.doublerCounter) loop.count += loop.counter;\n\t\t\t}\n\t\t\tif (!loop.doublerCounter || loop.count < loop.startDelay) loop.count += loop.counter;\n\t\t}\n\n\t\tattack += attackStep.getRandom();\n\t\tattack = clamp(attack, 0.1, 1);\n\n\t\tcurrentCount++;\n\t\tif (currentCount === currentCountTotal) playTheme();\n\t}\n\n\tfunction getVoice(voice) {\n\t\tif (voice.includes('Synth')) return getSynth();\n\t\telse return getSampler(voice);\n\t}\n\n\tfunction getSynth() {\n\t\tconst fmSynth = new Tone.FMSynth({ \n\t\t\tvolume: params.volume || 0\n\t\t});\n\t\t\n\t\tif (withRecording) fmSynth.chain(Tone.Destination, recorder)\n\t\telse fmSynth.toDestination();\n\n\t\teffects.get(totalPlays).forEach(f => {\n\t\t\tif (withRecording) f.chain(Tone.Destination, recorder);\n\t\t\telse f.toDestination();\n\t\t\tfmSynth.connect(f);\n\t\t});\n\t\treturn fmSynth;\n\t}\n\n\tfunction getSampler(voice) {\n\t\tconst sampleFiles = getSampleFiles(voice);\n\t\t// console.log('sampleFiles', sampleFiles);\n\t\tconst sampler = new Tone.Sampler({\n\t\t\turls: sampleFiles,\n\t\t\tvolume: params.volume || 0,\n\t\t\trelease: 1,\n\t\t});\n\t\tif (withRecording) sampler.chain(Tone.Destination, recorder)\n\t\telse sampler.toDestination();\n\n\t\teffects.get(totalPlays).forEach(f => {\n\t\t\tif (withRecording) f.chain(Tone.Destination, recorder);\n\t\t\telse f.toDestination();\n\t\t\tsampler.connect(f);\n\t\t});\n\t\t\n\t\treturn sampler;\n\t}\n\n\tfunction getSampleFiles(voice) {\n\t\tconst sampleFiles = {};\n\t\tif (voice === 'choir') {\n\t\t\tconst letter = totalPlays < 3 ? 'U' : random('AEIOU'.split(''));\n\t\t\tfor (const note in SamplePaths[voice+letter]) {\n\t\t\t\tsampleFiles[note] = samples.get(`${voice}-${letter}-${note}`);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const note in SamplePaths[voice]) {\n\t\t\t\tsampleFiles[note] = samples.get(`${voice}-${note}`);\n\t\t\t}\n\t\t}\n\t\treturn sampleFiles;\n\t}\n\n\tfunction loadSamples() {\n\t\tlet urls = {};\n\t\tvoices.forEach(voice => {\n\t\t\tif (voice === 'choir') {\n\t\t\t\t'AEIOU'.split('').forEach(letter => {\n\t\t\t\t\tconst voiceSampleURLS = SamplePaths['choir'+letter];\n\t\t\t\t\tfor (const note in voiceSampleURLS) {\n\t\t\t\t\t\turls[`${voice}-${letter}-${note}`] = `${voice}/${letter}/${voiceSampleURLS[note]}`;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tfor (const note in SamplePaths[voice]) {\n\t\t\t\t\turls[`${voice}-${note}`] = `${voice}/${SamplePaths[voice][note]}`;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn urls;\n\t}\n\n\tfunction load(callback) {\n\t\tlet urls = loadSamples();\n\t\tconsole.time(`load ${voices.join(', ')}`);\n\t\tsamples = new Tone.ToneAudioBuffers({\n\t\t\turls: urls,\n\t\t\tbaseUrl: '../samples/',\n\t\t\tonload: () => {\n\t\t\t\tconsole.timeEnd(`load ${voices.join(', ')}`);\n\t\t\t\tif (callback) callback();\n\t\t\t}\n\t\t});\n\t}\n\n\tasync function saveRecording() {\n\t\tconst recording = await recorder.stop();\n\t\tconst url = URL.createObjectURL(recording);\n\t\tconst anchor = document.createElement(\"a\");\n\t\tconst audioName = prompt('Name clip', \"Doodoo_\" + new Date().toDateString().replace(/ /g, '-'));\n\t\tanchor.download = audioName + \".webm\";\n\t\tanchor.href = url;\n\t\tanchor.click();\n\t}\n\n\tfunction moveTonic(dir) {\n\t\tlet n = MIDI_NOTES.indexOf(transform) + dir;\n\t\ttransform = MIDI_NOTES[n];\n\t}\n\n\tfunction setTonic(note) {\n\t\ttransform = note;\n\t}\n\n\tfunction printLoops() {\n\t\tconsole.log('loops', loops); // debug\n\t}\n\n\tfunction getLoops() {\n\t\treturn loops;\n\t}\n\n\tfunction moveBPM(n) {\n\t\tlet b = Tone.Transport.bpm.value;\n\t\tTone.Transport.bpm.value = b + n;\n\t}\n\n\tfunction setBPM(bpm) {\n\t\tTone.Transport.bpm.value = bpm; // starts 128\n\t}\n\n\tfunction getIsPlaying() {\n\t\treturn isPlaying;\n\t}\n\n\tfunction isRecording() {\n\t\treturn recorder.state === 'started' || recorder.state === 'paused';\n\t}\n\n\tfunction play() {\n\t\tif (!params.autoLoad) return loadTone();\n\t\tif (Tone.Transport.state === 'stopped') playTheme();\n\t\tisPlaying = true;\n\t\tif (withRecording) recorder.start();\n\t}\n\n\tfunction stop() {\n\t\tTone.Transport.stop();\n\t\tisPlaying = false;\n\t\tif (withRecording && recorder.state === 'started') saveRecording();\n\t}\n\n\tfunction mutate() {\n\t\tparts.forEach(part => {\n\t\t\tpart.update();\n\t\t});\n\t}\n\n\treturn { play, stop, mutate, moveTonic, setTonic, moveBPM, setBPM, getIsPlaying, isRecording, printLoops, getLoops, };\n}\n\nwindow.Doodoo = Doodoo;\n\n/*\n\t\n\tmelodies can be written just as notes\n\tparts: [\n\t\t'C4', null, 'E3', 'F3', 'G3', null, 'D3', 'E3', \n\t\t'D3', 'F3', 'E3', 'D3', 'F3', 'E3', 'D3', 'F3', \n\t], // from garden\n\n\tor including durations\n\tconst part1 = [\n\t\t['C#6', '2n'], ['D#6', '2n'], [null, '2n'], [null, '8n'], ['A#5', '8n'], ['G#5', '8n'], [null, '8n'],\n\t\t['C#6', '2n'], ['D#6', '2n'], ['E6', '2n'], [null, '4n'], ['B5', '8n'], ['A5', '8n'],\n\t\t['E6', '2n'], ['F#6', '2n'], ['G#6', '2n'], [null, '4n'], ['C#7', '8n'], ['D#7', '8n'], \n\t\t['C#7', '8n'], [null, '8n'], ['A#6', '4n'], ['G#6', '4n'], ['A#6', '8n'], ['G#6', '4n'], ['A#6', '8n'], ['G#6', '8n'], ['A#6', '8n'], ['G#6', '4n'], [null, '8n']\n\t]; // from\n\n\tuse midi notes or letter notes\n\t// const melody = [60, 57, 55, 62, 64, 67, 69, 72, 60, 74, 72, 74];\n\t// const melody = ['C4', 'A3', 'G3', 'D4', 'E4', 'G4', 'A4', 'C5', 'C4', 'D5', 'C5', 'D5'];\n*/\n\n// https://www.guitarland.com/MusicTheoryWithToneJS/PlayMajorScale.html\n// http://www.myriad-online.com/resources/docs/manual/english/gregorien.htm\n\n// https://en.wikibooks.org/wiki/IB_Music/Music_History/Medieval_Period#:~:text=The%20Gregorian%20chant%20began%20to,independently%20of%20the%20original%20chant.\n/*\n\tThe Gregorian chant began to evolve around 700. From 700 - 900, composers would write a line in parallel motion to the chant at a fixed interval of a fifth or a fourth above the original line. This technique evolved further from 900 - 1200. During this period, the upper line moved independently of the original chant. After 1100, upper lines even began gaining rhythmic independence.\n*/\n\n// https://github.com/saebekassebil/teoria\n\n"]}